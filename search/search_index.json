{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>fmov is a blazing-fast Python library for rendering videos frame-by-frame using <code>PIL</code> (Pillow). It combines the simplicity of high-level APIs with the performance of low-level tools like FFmpeg \u2014 perfect for generative art, animations, or automated video creation.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast: Built on FFmpeg for high-performance rendering.</li> <li>Simple: Use <code>PIL.Image</code> to draw and render.</li> <li>Scalable: No confusing flags or unreadable code.</li> <li>Audio Support: Register sound effects from within your frame function, at any frame or timestamp.</li> <li>Interactive Preview: Scrub, play, and debug your animation before rendering.</li> <li>Helpful Utilities: Easy time/frame conversions.</li> <li>Modern Pythonic API: Functional, frame-driven, and context-free.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fmov\n</code></pre> <p>You must also have FFmpeg installed on your system and available in your PATH.</p> <pre><code>sudo apt install ffmpeg     # Linux\nbrew install ffmpeg         # MacOS\nchoco install ffmpeg        # Windows\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from fmov import Video\nfrom PIL import Image\n\ndef generate_frame(frame: int, video: Video) -&gt; Image:\n    img = Image.new(\"RGB\", (video.width, video.height), \"#000000\")\n    return img\n\nvideo = Video(path=\"output.mp4\", dimensions=(1920, 1080), fps=30, function=generate_frame, length=\"5s\")\nvideo.preview()  # Interactive preview\nvideo.save()     # Render to file\n</code></pre>"},{"location":"Examples/1simple/","title":"Simple Example","text":"main.py<pre><code>from fmov import Video\nfrom PIL import Image, ImageDraw\n\nwith Video(\"video.mp4\", (1920//2, 1080//2), fps=120) as video: #(1)\n    for i in range(video.seconds_to_frame(30)): #(2)\n        img = Image.new(\"RGB\", (video.width, video.height), \"#000000\") #(3)\n        draw = ImageDraw.Draw(img) #(4)\n\n        #          x    y                 content of the text                     color\n        draw.text((100, video.height//2), f\"Hello world! This is frame {str(i)}\", fill=\"#ffffff\")\n\n        video.pipe(img) #(5)\n\n    video.sound(path=\"./audio.wav\", at=\"100\", volume=0.5)\n\n    video.sound(path=\"./audio.wav\", at=\"4000ms\")\n\n    video.sound(path=\"./audio.wav\", at=\"25s 500ms\")\n</code></pre> <ol> <li> <p>Creating the video via Context Manager. This video is a 1920 x 1080 video with a fps of 120fps. The video will be saved at './video.mp4'</p> </li> <li> <p>This code loops through every frame that will make up a 30 second video</p> </li> <li> <p>This creates the base image that we will draw on, the image is the same size as the video and will have a background color of black</p> </li> <li> <p>This creates the draw context along with the image, which allows us to draw rectangles, text, etc.</p> </li> <li> <p>This adds the frame to the video</p> </li> </ol> <p>Note</p> <p>For more about how to create frames with PIL, visit the PIL documentation</p>"},{"location":"Examples/2dvd_bounce/","title":"DVD Bounce Example","text":"main.py<pre><code>from PIL import Image\nimport random\nfrom fmov import Video\n\nwith Video(path=\"./video.mp4\", (1920,1080), fps=30) as video:\n    # position and velocity of the dvd logo\n    x,y = (0,0)\n    v = 180//video.fps\n    vx, vy = (v,v)\n\n    total_frames = video.time_to_frame(\"1m\")\n\n    # using rich.track to keep track of the progress, does a good job of predicting ETA usually\n    # keep in mind that this only counts the loading of the video, the audio comes afterward but\n    # usually is negligable unless you have a large file with many effects\n    for i in track(range(total_frames), \"Rendering...\", total=total_frames):\n        # initializing the common PIL variables\n        image = Image.new(\"RGB\", (video.width, video.height), \"#000000\")\n        #draw = ImageDraw.Draw(image) # usually you need this to draw shapes and text, however this example doesnt require it\n\n        # adding the dvd image\n        # finding the fill color based on the hue, turn it into an image, and use the dvd image as a mask\n        fill_color = Image.new(\"HSV\", (1, 1), (hue, 200, 220)).convert(\"RGB\").getpixel((0, 0))\n        color_layer = Image.new(\"RGB\", dvd_img.size, fill_color)\n        image.paste(color_layer, (x, y), dvd_img.convert(\"L\") if dvd_img.mode != \"RGBA\" else dvd_img.split()[3])\n\n        # collision detection\n        bumped = False\n        if x+vx &gt;= video.width-img_width or x+vx &lt;= 0:\n            vx *= -1\n            bumped = True\n        if y+vy &gt;= video.height-img_height or y+vy &lt;= 0:\n            vy *= -1\n            bumped = True\n\n        # play a sound effect and shift the hue of the logo on a bump\n        if bumped:\n            video.sound(path=\"./audio.wav\", at=i)\n            hue = (hue+random.randint(20,60))%255\n\n        # position updates\n        x += vx\n        y += vy\n\n        # finally, append the frame to the end of the video\n        video.pipe(image)\n</code></pre>"},{"location":"Video/1video/","title":"Initializing the Video","text":"<p>The core class of the fmov library is the <code>Video</code> class. This is where you define your video, how frames are generated, and how it is rendered.</p> <pre><code>from fmov import Video\n</code></pre>"},{"location":"Video/1video/#creating-a-video-modern-api","title":"Creating a Video (Modern API)","text":"<p>The recommended way to use fmov is to provide a frame function and a length, then preview and render:</p> main.py<pre><code>from fmov import Video\nfrom PIL import Image\n\n    with Video(\"./output.mp4\", (1920, 1080)) as video:\n\n        for i in video.seconds_to_frame(30):\n\nvideo = Video(path=\"./output.mp4\", dimensions=(1920, 1080), fps=30, function=generate_frame, length=\"30s\")\nvideo.preview()  # Interactive preview and scrubbing\nvideo.save()     # Render to file\n</code></pre> <ul> <li>The <code>generate_frame</code> function describes how to create each frame.</li> <li>The <code>Video</code> object is created with the frame function and length.</li> <li><code>video.preview()</code> allows you to interactively scrub and debug before rendering.</li> <li><code>video.save()</code> renders the video to the output path.</li> </ul> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p> Traditional <pre><code>from fmov import Video\nfrom PIL import Image\n\nvideo = Video(\"./output.mp4\", (1920, 1080))\n\nfor i in video.time_to_frame(\"30s\"):\n\n    image = Image.new(\"RGB\", (video.width, video.height), \"#000000\")\n\n    video.pipe(image)\n\nvideo.render()\n</code></pre> <p>Tip</p> <p>It's recommended to use the context manager, as it allows for automatic rendering once the context has ended. However, some solutions may require the traditional method of manually calling the render function.</p>"},{"location":"Video/1video/#_1","title":"=======","text":"<p>35d02148043239ef723fd6612c3321cd5fcd6de2</p>"},{"location":"Video/1video/#parameters","title":"Parameters","text":"<p>When calling the <code>Video</code> function, many parameters can be tweaked. Here are all of them in order:</p>"},{"location":"Video/1video/#path-str-videomp4","title":"<code>path: str = \"./video.mp4\"</code>","text":"<p>Specifies where the output file will be saved. Can be absolute or relative.</p>"},{"location":"Video/1video/#dimensions-tupleint-int-1920-1080","title":"<code>dimensions: tuple[int, int] = (1920, 1080)</code>","text":"<p>Specifies the width and height of the video.</p> <p>Specifies the width and height of the video</p> example<pre><code># This will create a standard 1920 x 1080 video\nvideo = Video(dimensions=(1920, 1080))\n</code></pre>"},{"location":"Video/1video/#fps-int-30","title":"<code>fps: int = 30</code>","text":"<p>Specifies the frames per second of the video</p>"},{"location":"Video/1video/#vcodec-str-libx264","title":"<code>vcodec: str = \"libx264\"</code>","text":"<p>Specifies the video codec. List of supported codecs</p>"},{"location":"Video/1video/#pix_fmt-str-yuv420p","title":"<code>pix_fmt: str = \"yuv420p\"</code>","text":"<p>Specifies the pixel format. List of supported pixel formats</p>"},{"location":"Video/1video/#render_preset-str-ultrafast","title":"<code>render_preset: str = \"ultrafast\"</code>","text":"<p>Specifies the render speed for FFmpeg. - ultrafast - superfast - veryfast - faster - fast - medium - slow - slower - veryslow</p>"},{"location":"Video/1video/#crf-int-8","title":"<code>crf: int = 8</code>","text":"<p>The Constant Rate Factor (level of compression for the vcodec). - 0 is lossless - 23 is default - 51 is most compressed</p>"},{"location":"Video/1video/#audio_bitrate-str-192k","title":"<code>audio_bitrate: str = \"192k\"</code>","text":"<p>The bitrate of the audio, essentially the quality of the sound.</p>"},{"location":"Video/1video/#log_duration-bool-true","title":"<code>log_duration: bool = True</code>","text":"<p>This specifies whether the Video object will print out the length it took to render.</p> <p>Tip</p> <p>The new API is recommended for most users. If you need more control, you can still use the context manager and <code>.pipe()</code> methods, but the functional API is simpler and more powerful for most workflows.</p>"},{"location":"Video/2converters/","title":"Time &amp; Frame Conversions","text":"<p>fmov provides a set of helpful utilities for converting between frames and time units. This makes it easy to synchronize animation, audio, and effects.</p> example<pre><code>video = Video(fps=30)\n\nvideo.time_to_frame(\"2s\") # 60\nvideo.frame_to_seconds(60) # 2\n</code></pre>"},{"location":"Video/2converters/#time_to_frametime-unionstr-int-int","title":"<code>time_to_frame(time: Union(str | int)) -&gt; int</code>","text":"<p>Returns the frames for a given time code</p> time_codes<pre><code>video = Video(fps=30)\n\nvideo.time_to_frame(\"1m\") # 1800\nvideo.time_to_frame(\"1m 30s\") # 2700\nvideo.time_to_frame(\"3h 10m 25s 500ms\") # 342765\nvideo.time_to_frame(10) # 10\n</code></pre>"},{"location":"Video/2converters/#frame_to_millisecondsframe-int-int","title":"<code>frame_to_milliseconds(frame: int) -&gt; int</code>","text":"<p>Returns the time in milliseconds that the given frame will begin.</p>"},{"location":"Video/2converters/#frame_to_secondsframe-int-float","title":"<code>frame_to_seconds(frame: int) -&gt; float</code>","text":"<p>Returns the time in seconds that the given frame will begin.</p>"},{"location":"Video/2converters/#frame_to_minutesframe-int-float","title":"<code>frame_to_minutes(frame: int) -&gt; float</code>","text":"<p>Returns the time in minutes that the given frame will begin.</p>"},{"location":"Video/3audio/","title":"Adding Audio","text":"<p>You can add audio events from within your frame function using the <code>video.audio(path, at, volume)</code> method. This allows you to register sound effects at any frame or timestamp, making it easy to synchronize audio with animation events.</p> example<pre><code>from fmov import Video\nfrom PIL import Image\n\nvideo.sound(\"./pop.wav\", \"1s\")     # add sound at 1 second\nvideo.sound(\"./click.mp3\", 120)    # add sound at 120th frame\nvideo.sound(\"./chime.m4a\", \"3m\")   # add sound at 3 minutes\n</code></pre>"},{"location":"Video/3audio/#soundpath-str-at-unionstr-int-volume-float-04","title":"`sound(path: str, at: Union(str | int), volume: float: 0.4)","text":"<p>Puts a sound at a given time code</p>"},{"location":"Video/4other/","title":"Miscellaneous Utilities","text":""},{"location":"Video/4other/#set_pathpath-str-none","title":"<code>set_path(path: str) -&gt; None</code>","text":"<p>Updates the output path for the video file. Useful if you want to change the output location after creating the <code>Video</code> object.</p> example<pre><code>video = Video(path=\"./original.mp4\")\nvideo.set_path(\"./new_output.mp4\")\n</code></pre>"},{"location":"Video/4other/#get_path-str","title":"<code>get_path() -&gt; str</code>","text":"<p>Returns the current output path for the video file.</p> example<pre><code>current_path = video.get_path()\n</code></pre>"}]}